/* Autogenerated with kurento-module-creator */

#include <gst/gst.h>
#include "colorDetectorOpenCVImpl.hpp"
#include <KurentoException.hpp>
#include <memory>
#include "Media.hpp"

#define AREA_THRESHOLD 200


#define GST_CAT_DEFAULT kurento_color_detector_filter_impl

GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);

#define GST_DEFAULT_NAME "KurentoColorDetectorFilterImpl"

namespace kurento
{
namespace module
{
namespace colordetector
{

void applyThreshold(cv::Mat &src, IplImage *dst);
void estimatePosition(IplImage *image, int *pX, int *pY);

colorDetectorOpenCVImpl::colorDetectorOpenCVImpl ()
{
}

/*
 * This function will be called with each new frame. mat variable
 * contains the current frame. You should insert your image processing code
 * here. Any changes in mat, will be sent through the Media Pipeline.
 */
void colorDetectorOpenCVImpl::process (cv::Mat &frame)
{
    int posX = -1, posY = -1;

    cv::flip(frame, frame, 1);
    IplImage *threshed = cvCreateImage(frame.size(), 8, 1);
    applyThreshold(frame, threshed);

    estimatePosition(threshed, &posX, &posY);

    if (posX > 0 && posY > 0) {
      GST_WARNING ("Sending Event: ColorDetected");
      try {
           ColorDetected cd (this->getSharedPtr(), ColorDetected::getName(), posX, posY);

           signalColorDetected (cd);
           GST_WARNING ("Sent Event: ColorDetected");
      } catch (std::bad_weak_ptr &e) {
           GST_ERROR ("Could not send Event: ColorDetected");
      }
    }

    cvReleaseImage(&threshed);  
}

/* Applies an intensity threshold to the src image.
 * It basically converts the src image into a black
 * and white image, in which all the yellow shades
 * have been converted to plain white and all the
 * rest is set to black.
 *
 * Params:
 *    src - The original image.
 *    dst - The threshed image.
 */

void applyThreshold(cv::Mat  &src, IplImage *dst)
{
  IplImage *hsvImage = cvCreateImage(src.size(), 8, 3);
  cv::Mat hsvMat (hsvImage);
  cv::cvtColor(src, hsvMat, CV_BGR2HSV);
  cvInRangeS(hsvImage, cvScalar(20, 100, 100), cvScalar(30, 255, 255), dst);
  cvReleaseImage(&hsvImage);
}



/* Tries to estimate the position of the pixels'
 * intensities barycentre, using the "Moments method".
 * If the maximum intensity detected across the image
 * is not relevant, then both coordinates are set to
 * -1.
 *
 * Further readings:
 *    http://en.wikipedia.org/wiki/Image_moment
 *
 * Params:
 *    image - The original image.
 *    pX    - The barycentre's X coordinate.
 *    pY    - The barycentre's Y coordinate.
 */

void estimatePosition(IplImage *image, int *pX, int *pY)
{
  CvMoments moments = CvMoments();
  cvMoments(image, &moments, 1);

  double moment10 = cvGetSpatialMoment(&moments, 1, 0);
  double moment01 = cvGetSpatialMoment(&moments, 0, 1);
  double area     = cvGetCentralMoment(&moments, 0, 0);

  if (area >= AREA_THRESHOLD) {
    *pX = moment10 / area;
    *pY = moment01 / area;
  } else {
    *pX = -1;
    *pY = -1;
  }
}


} /* colordetector */
} /* module */
} /* kurento */
